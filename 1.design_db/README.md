# Задание 1: Проектирование схемы БД

## ER Диаграмма
Схема создана в сервисе [app.diagrams.net](https://app.diagrams.net/#G1bLuMsimx5jykM-r0WPpKInOpm8kdANOJ). Для просмотра или редактирования необходимо авторизоваться через Google Drive.

![ER Диаграмма схемы БД](https://github.com/jmp-ff25/it_guru_test_task/blob/main/1.design_db/scheme_db_draw.io.png)

## 1. Цель
Спроектировать реляционную схему для хранения:
- Номенклатуры товаров (артикул/SKU, название, цена, остаток).
- Иерархии категорий произвольной глубины.
- Клиентов.
- Заказов и их составов (позиции с количеством и ценой на момент заказа).

Схема должна поддерживать рост данных (тысячи заказов в день), удобные запросы аналитики (топы продаж, суммы по клиентам) и расширяемость.

## 2. Обзор сущностей и связей
Итоговые таблицы:
- `categories` — дерево категорий (adjacency list через `parent_id`).
- `nomenclature` — товары (без прямого `category_id` — связь теперь M:N).
- `nomenclature_categories` — таблица связи M:N между товарами и категориями.
- `clients` — покупатели.
- `orders` — заказы клиентов.
- `order_items` — позиции заказа (association object между `orders` и `nomenclature`).

### 2.1 Дерево категорий
Использована модель adjacency list: каждая строка хранит `parent_id` (FK -> `categories.id`). Это простой и гибкий способ без фиксированного лимита уровней вложенности.

Плюсы: простота DDL и модификаций. Минусы: рекурсивные запросы для выборок по всем уровням.

Потенциальные альтернативы для масштабирования:
- Closure Table (быстрый поиск всех предков/потомков). 
- Materialized Path (строка с путём; проста для чтения, требует контроль целостности).
- Nested Sets (быстрые диапазонные выборки, дороже обновления).

### 2.2 Связь между товарами и категориями (M:N)
Изначально была модель "товар принадлежит одной категории" через `nomenclature.category_id` (1:M). Реальные кейсы требуют принадлежность к нескольким категориям (брендовые, функциональные, маркетинговые группы и т.п.).

Решение: таблица `nomenclature_categories` с составным PK `(nomenclature_id, category_id)`.

**Преимущества:**
- Уникальность пар (исключение дубликатов).
- Гибкость маркетинговой классификации.
- Отсутствие избыточности (нет необходимости дублировать строки товара для разных категорий).
- Упрощение двунаправленных выборок: все категории товара / все товары категории.

### 2.3 Связь заказов и товаров
Связь M:N реализована через `order_items`.
- Каждая строка отражает участие товара в конкретном заказе.
- Дополнительные атрибуты: `quantity`, `price_at_order` (фиксация исторической цены независимо от текущей `nomenclature.price`).
- Используется составной PK `(order_id, nomenclature_id)`.

> Важно: Повторение значений `order_id` в таблице допустимо (один заказ содержит множество товаров). Уникальна только комбинация `(order_id, nomenclature_id)`. Первичная формулировка «`order_id` не может повторяться» — некорректна. Если потребуется хранить несколько строк одного и того же товара в заказе (например, разные скидки, партия поставляется частями), то текущий составной PK будет ограничением; в таком случае либо добавляется surrogate PK, либо в комбинацию PK включают дополнительный атрибут (например, `line_no`). На текущем этапе достаточно составного PK.

### 2.4 SKU в `nomenclature`
Добавлен поле `sku` (артикул) — бизнес-идентификатор, уникальный в пределах каталога. Он позволяет:
- Быстро находить товар по коду.
- Избежать жёсткой привязки логики к surrogate PK.
- Облегчить интеграции с внешними системами.

## 3. Концептуальная структура (без SQL синтаксиса)
Ниже — описание проектируемых таблиц и ключей как архитектурного решения (логическая модель). Типы данных, индексы и каскады удалений опущены намеренно — важна структура и мотивация.

```
categories
-----------
id (PK)
name
parent_id (FK → categories.id)            // adjacency list; NULL для корневых
UNIQUE (lower(name), parent_id)           // уникальность имени (без учёта регистра) в рамках одного родителя
slug (UNIQUE)                             // глобально уникальный стабильный идентификатор для URL/интеграций

nomenclature
-------------
id (PK)
sku (UNIQUE)                              // бизнес-идентификатор
name
price                                     // актуальная цена сейчас
quantity                                  // текущий остаток
updated_at                                // служебное поле актуализации

nomenclature_categories
------------------------
nomenclature_id (FK → nomenclature.id)
category_id (FK → categories.id)
PRIMARY KEY (nomenclature_id, category_id) // исключает дубликаты связок товар–категория

clients
--------
id (PK)
name
address

orders
--------
id (PK)
client_id (FK → clients.id)
created_at
status                                    // жизненный цикл: created / paid / shipped ...

order_items
-------------
order_id (PK, FK → orders.id)
nomenclature_id (PK, FK → nomenclature.id)
quantity                                  // >0
price_at_order                            // зафиксированная историческая цена
```

Пояснения к ключевым решениям:
- `parent_id` реализует дерево категорий с произвольной глубиной.
- Уникальность по `lower(name), parent_id` предотвращает дубликаты отличающиеся только регистром ("Телевизоры" vs "телевизоры"). Если в будущем потребуется локализация — лучше будет хранить уникальный slug.
- `slug` — неизменяемый (или редко меняемый) глобальный идентификатор категории для адресации, SEO и интеграций; позволяет иметь повторяемые `name` в разных ветках.
- `nomenclature_categories` вводится для M:N: один товар в нескольких категориях (бренд/тип/серия).
- В `order_items` используется составной первичный ключ `(order_id, nomenclature_id)` для уникальности товара внутри заказа и хранения атрибутов связи (quantity, price_at_order). Отказ от surrogate `id` уменьшает лишнюю колонку; если появятся варианты строки (например, разные скидки одного товара в заказе), модель эволюционирует: добавится поле `line_no` или surrogate `id`.
- `sku` — стабильный внешний ключ для интеграций и быстрого поиска.

Это логический слой. Физическая реализация (типы, индексы, каскады, ограничения CHECK) будет представлена на следующем этапе или вынесена в отдельный технический документ.

## 4. Ключи и индексы
- Составные PK используются для M:N ассоциаций.
- Уникальные бизнес-ключи: `nomenclature.sku`.
- Индексы по внешним ключам (`parent_id`, `client_id`, `nomenclature_id`) для ускорения JOIN / фильтрации.
- Потенциал добавления частичных/покрывающих индексов при росте запросов аналитики.

## 5. Почему добавлен slug
При анализе дерева категорий я увидел, что само имя категории не всегда удобно использовать как универсальный ключ: оно может повторяться у разных родителей, его могут захотеть переименовать или локализовать. Хотелось иметь отдельный стабильный, компактный идентификатор, который можно безопасно класть в URL, кэш, внешние интеграции и не бояться переименований. Так появился `slug` — короткая нормализованная строка (латиница, дефисы), которую я генерирую из имени и стараюсь больше не трогать.

Причины включения `slug` в модель категорий:
1. Повторяемость имён в разных ветках (Nokia → Bluetooth, Samsung → Bluetooth). Глобально уникальный `slug` позволяет адресовать каждую категорию вне контекста родителя.
2. Переименование: бизнес может менять отображаемое `name`; стабильный `slug` сохраняет внешние ссылки и кэш.
3. Локализация: `name` может иметь варианты по языкам, `slug` остаётся универсальным.
4. SEO и человекочитаемые URL: `.../c/smartphones/nokia-bluetooth` лучше, чем `.../c/42`.
5. Интеграции и кэширование: короткие строковые ключи удобны для Redis/HTTP API; можно отдавать и принимать `slug` вместо числового `id`.
6. Предотвращение коллизий при слиянии веток: глобальная уникальность `slug` снижает риск конфликтов.

Взаимодействие ограничений:
- `UNIQUE (lower(name), parent_id)` гарантирует локальную уникальность отображаемых имён.
- `slug (UNIQUE)` обеспечивает глобальную идентификацию.

Практика заполнения:
- Генерация при создании: транслитерация `name` + нормализация (строчные буквы, заменяем пробелы на `-`).
- Проверка конфликтов: при совпадении добавлять суффикс (`-2`, `-nokia`).
- Политика изменений: slug менять только в исключительных случаях; при изменении — выполнять редиректы / обновлять кэш.

## 6. Потенциальные дальнейшие шаги
- Реализация REST API сервиса «Добавление товара в заказ» (пункт 3 задания) — endpoint: `POST /orders/{order_id}/items` с телом `{ sku, quantity }`.
- Добавление аудита изменений цен (`price_history`).
- Closure table для категорий: `category_tree(category_id, ancestor_id, depth)`.
- Материализованные представления для популярных аналитических выборок.
- Полнотекстовый поиск по товарам (pg_trgm, GIN индекс).

## 7. Краткое резюме решений
| Задача | Выбор | Обоснование |
|--------|-------|-------------|
| Иерархия категорий | Adjacency List | Простота, достаточно для начального этапа |
| Товар в нескольких категориях | Таблица связи | Гибкость, отсутствие дубликатов |
| Историческая цена | Поле `price_at_order` | Корректная аналитика задним числом |
| Первичные ключи в M:N | Составные PK | Явная уникальность и меньше суррогатов |
| Быстрый поиск товара | Уникальный `sku` | Интеграции и бизнес-привязка |

## 8. Примечания
- Валидация бизнес-правил (доступность товара, остатки) — задача прикладного уровня или триггеров.
- Возможное добавление поля `discount` в `order_items` потребует расширения PK или surrogate ключа при появлении нескольких ценовых строк одного товара.
